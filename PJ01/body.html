<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sectors mit Bildern</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            background: #222;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        .mainbody {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 Spalten */
            gap: 10px;
            width: 80%;
            max-width: 900px;
            background-color: rgb(231, 231, 231);
            padding: 10px;
        }

        .sectors {
            border-radius: 6px;
            color: white;
            aspect-ratio: 5 / 4;     /* Höhe : Breite = 5 : 4 */
            position: relative;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        /* Hover-Effekt: leicht vergrößern + Schatten */
        .sectors:hover {
            transform: scale(1.03);
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
            z-index: 5;
        }

        .sectors.big {
            grid-column-end: span 2;
            grid-row-end: span 2;
        }

        .sectors img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            cursor: pointer;
            border-radius: 6px; /* Bild folgt der Rundung des Containers */
        }

        /* Reihe mit [01] [11454] [3533] oben im Bild */
        .overlay {
            position: absolute;
            top: 4px;
            left: 4px;
            background: none;
            padding: 0;
            display: flex;
            gap: 4px;
            align-items: center;
            font-size: 0.8rem;
        }

        /* Basis-Styling für alle Badges */
        .overlay .badge {
            position: relative;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            min-width: 36px;
            text-align: center;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.55);
        }

        /* ID-Badge (nur Anzeige, keine Interaktion) */
        .overlay .badge-id {
            font-weight: 600;
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(255, 255, 255, 0.9);
            cursor: default;
        }

        .overlay .badge-id:hover {
            /* kein Hover-Effekt für die ID */
            transform: none;
            box-shadow: none;
        }

        /* Interaktive Info-Badges 2 & 3 */
        .overlay .badge-info {
            font-family: monospace;
            cursor: pointer;
            transition: background-color 0.15s ease,
                        transform 0.1s ease,
                        box-shadow 0.15s ease;
        }

        .overlay .badge-info:hover {
            transform: scale(1.02);
            background: rgba(0, 0, 0, 0.75);
            box-shadow: 0 0 6px rgba(0, 0, 0, 0.4);
        }

        .overlay .badge-info:active {
            transform: scale(0.96);
        }

        /* Zuletzt angeklickte Info-Badge */
        .overlay .badge-info.active {
            background: rgba(0, 160, 0, 0.9);
            border-color: #ffffff;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.7);
        }

        .copy-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 3px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            animation: copied-pop 0.9s ease-out forwards;
            z-index: 10;
        }

        @keyframes copied-pop {
            0%   { opacity: 0; }
            15%  { opacity: 1; }
            85%  { opacity: 1; }
            100% { opacity: 0; }
        }

        .image-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .image-modal.visible {
            display: flex;
        }

        .image-modal-content {
            max-width: 90vw;
            max-height: 90vh;
        }

        .image-modal-content img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="mainbody" id="mainbody"></div>

    <!-- Modal für großes Bild -->
    <div class="image-modal" id="imageModal">
        <div class="image-modal-content">
            <img id="modalImage" src="" alt="">
        </div>
    </div>

    <script>
        // =========================
        // Grundeinstellungen
        // =========================
        const COLS = 4;
        const TOTAL_SECTORS = 26;
        const BIG_SECTORS = 2;
        const IMAGE_BASE_PATH = 'img';  // Ordnerpfad mit deinen Bildern

        // Sound-Effekt (liegt im Root neben dieser HTML-Datei)
        const clickSound = new Audio('sfx.mp3');

        // =========================
        // Manuelle Info-Reihen
        // =========================
        const infoRow1 = [
            "11454", // 01
            "11687", // 02
            "11836", // 03
            "12305", // 04
            "10459", // 05
            "5471",  // 06
            "13068", // 07
            "4004",  // 08
            "22302", // 09
            "22017", // 10
            "21967", // 11
            "22394", // 12
            "22019", // 13
            "19761", // 14
            "22364", // 15
            "22392", // 16
            "11898", // 17
            "21859", // 18
            "22396", // 19
            "22091", // 20
            "22030", // 21
            "21937", // 22
            "22362", // 23
            "22395", // 24
            "",      // 25
            ""       // 26
        ];

        while (infoRow1.length < TOTAL_SECTORS) {
            infoRow1.push("");
        }

        const infoRow2 = [
            "3533",   // 01
            "3706",   // 02
            "3815",   // 03
            "4129",   // 04
            "2970",   // 05
            "389",    // 06
            "4736",   // 07
            "51",     // 08
            "12298",  // 09
            "12070",  // 10
            "12030",  // 11
            "12389",  // 12
            "12072",  // 13
            "10080",  // 14
            "12356",  // 15
            "12387",  // 16
            "3857",   // 17
            "11938",  // 18
            "12391",  // 19
            "8941",   // 20
            "12077",  // 21
            "12009",  // 22
            "12354",  // 23
            "12390",  // 24
            "15597",  // 25
            "14185"   // 26
        ];

        while (infoRow2.length < TOTAL_SECTORS) {
            infoRow2.push("");
        }

        // =========================
        // Grid-Berechnung (2 große Sektoren, keine Lücken)
        // =========================
        const totalCells = TOTAL_SECTORS + 3 * BIG_SECTORS; // 26 + 6 = 32
        const ROWS = totalCells / COLS; // 32 / 4 = 8

        if (!Number.isInteger(ROWS)) {
            console.warn('Konfiguration passt nicht exakt ins Grid!');
        }

        const bigBlocks = []; // Positionen der 2x2-Blöcke (top-left)

        function blocksOverlap(r1, c1, r2, c2) {
            // Prüfen, ob sich zwei 2x2-Blöcke überlappen
            return !(r1 + 1 < r2 || r1 > r2 + 1 || c1 + 1 < c2 || c1 > c2 + 1);
        }

        // Zufällig zwei 2x2-Blöcke setzen (ohne Überlappung)
        while (bigBlocks.length < BIG_SECTORS) {
            const r = Math.floor(Math.random() * (ROWS - 1)); // 0..ROWS-2
            const c = Math.floor(Math.random() * (COLS - 1)); // 0..COLS-2

            let ok = true;
            for (const b of bigBlocks) {
                if (blocksOverlap(r, c, b.row, b.col)) {
                    ok = false;
                    break;
                }
            }
            if (!ok) continue;

            bigBlocks.push({ row: r, col: c });
        }

        function cellInBig(r, c) {
            // Gibt den Block zurück, falls diese Zelle in einem 2x2-Block liegt
            return bigBlocks.find(b =>
                r >= b.row && r <= b.row + 1 &&
                c >= b.col && c <= b.col + 1
            );
        }

        // =========================
        // Sector-Konfiguration aufbauen
        // =========================
        const sectorsConfig = [];
        let id = 1;

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const block = cellInBig(r, c);

                if (block) {
                    // Zelle gehört zu einem großen Block
                    if (r === block.row && c === block.col) {
                        // nur oben links erzeugen wir das große Element
                        sectorsConfig.push({
                            id,
                            rowStart: r + 1,   // CSS Grid ist 1-basiert
                            colStart: c + 1,
                            big: true
                        });
                        id++;
                    }
                    // andere 3 Zellen des Blocks werden vom großen Element überdeckt
                } else {
                    // normaler Sector
                    sectorsConfig.push({
                        id,
                        rowStart: r + 1,
                        colStart: c + 1,
                        big: false
                    });
                    id++;
                }
            }
        }

        if (sectorsConfig.length !== TOTAL_SECTORS) {
            console.warn('Anzahl der erzeugten Sectors stimmt nicht:', sectorsConfig.length);
        }

        // =========================
        // Hilfsfunktionen
        // =========================
        function copyToClipboard(text) {
            if (!text || text === '-----') return;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).catch(err => {
                    console.error('Clipboard Fehler:', err);
                });
            } else {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                } catch (err) {
                    console.error('Clipboard Fallback Fehler:', err);
                }
                document.body.removeChild(textarea);
            }
        }

        function showCopiedBubble(badgeEl) {
            const old = badgeEl.querySelector('.copy-tooltip');
            if (old) old.remove();

            const tooltip = document.createElement('div');
            tooltip.className = 'copy-tooltip';
            tooltip.textContent = 'Kopiert!';
            badgeEl.appendChild(tooltip);

            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.parentNode.removeChild(tooltip);
                }
            }, 1000);
        }

        function playClickSound() {
            try {
                clickSound.currentTime = 0;
                clickSound.play();
            } catch (e) {
                console.warn('Konnte SFX nicht abspielen:', e);
            }
        }

        function makeIdBadge(text) {
            const span = document.createElement('span');
            span.className = 'badge badge-id';
            span.textContent = text;
            // keine Events, kein Kopieren
            return span;
        }

        function makeInfoBadge(text) {
            const span = document.createElement('span');
            span.className = 'badge badge-info';
            span.textContent = text;

            span.title = 'Klicken zum Kopieren';
            span.addEventListener('click', (e) => {
                e.stopPropagation(); // kein Bild-Popup auslösen

                if (!text || text === '-----') return;

                copyToClipboard(text);
                playClickSound();

                // Alle bisherigen aktiven Info-Badges entfernen
                document.querySelectorAll('.badge-info.active').forEach(b => {
                    b.classList.remove('active');
                });

                span.classList.add('active');
                showCopiedBubble(span);
            });

            return span;
        }

        // =========================
        // Popup / Modal Setup
        // =========================
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');

        function openModalWithImage(src, alt) {
            modalImg.src = src;
            modalImg.alt = alt || '';
            modal.classList.add('visible');
        }

        function closeModal() {
            modal.classList.remove('visible');
            modalImg.src = '';
            modalImg.alt = '';
        }

        // Klick außerhalb des Bildes schließt Modal
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });

        // ESC schließt Modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        // =========================
        // DOM aufbauen
        // =========================
        const mainbody = document.getElementById('mainbody');

        sectorsConfig.forEach(cfg => {
            const div = document.createElement('div');
            div.classList.add('sectors');
            if (cfg.big) div.classList.add('big');

            const idStr = String(cfg.id).padStart(2, '0');

            // Bild erzeugen
            const img = document.createElement('img');
            img.src = `${IMAGE_BASE_PATH}/${idStr}.jpg`;
            img.alt = `Bild ${idStr}`;
            img.onerror = () => {
                img.onerror = null;
                img.src = `${IMAGE_BASE_PATH}/${idStr}.png`;
            };

            // Klick auf Bild → großes Popup + Sound
            img.addEventListener('click', (e) => {
                e.stopPropagation();
                playClickSound();
                openModalWithImage(img.src, img.alt);
            });

            div.appendChild(img);

            // Overlay mit drei Badges
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            const idx = cfg.id - 1; // 0-basiert für Arrays

            const badgeId    = makeIdBadge(idStr);                     // nur Info
            const badgeInfo1 = makeInfoBadge(infoRow1[idx] || '-----');
            const badgeInfo2 = makeInfoBadge(infoRow2[idx] || '-----');

            overlay.appendChild(badgeId);
            overlay.appendChild(badgeInfo1);
            overlay.appendChild(badgeInfo2);

            div.appendChild(overlay);

            // Grid-Position setzen
            div.style.gridRowStart = cfg.rowStart;
            div.style.gridColumnStart = cfg.colStart;

            mainbody.appendChild(div);
        });
    </script>
</body>
</html>
