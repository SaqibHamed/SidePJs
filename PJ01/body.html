<!DOCTYPE html>
<html lang="de">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sectors</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            background: #222;
        }

        .mainbody {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4 Spalten */
            gap: 10px;
            width: 80%;
            max-width: 900px;
            background-color: aqua;
            border: 10px solid black;
            padding: 10px;
        }

        .sectors {
            background-color: blue;
            border: 2px dashed pink;
            color: white;
            font-size: 1.5rem;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;

            /* Verhältnis Höhe : Breite = 5 : 4 */
            aspect-ratio: 5 / 4;
        }

        .sectors.big {
            /* große Kacheln nehmen 2x2 Zellen ein */
            grid-column-end: span 2;
            grid-row-end: span 2;
        }
    </style>
</head>
<body>
    <div class="mainbody" id="mainbody"></div>

    <script>
        const COLS = 4;
        const TOTAL_SECTORS = 26;
        const BIG_SECTORS = 2;

        // Wieviele Zellen braucht das Grid insgesamt?
        // 1 normaler Sector = 1 Zelle
        // 1 großer Sector (2x2) = 4 Zellen = 1 Element + 3 extra Zellen
        const totalCells = TOTAL_SECTORS + 3 * BIG_SECTORS; // 26 + 6 = 32
        const ROWS = totalCells / COLS; // 32 / 4 = 8

        if (!Number.isInteger(ROWS)) {
            console.warn('Konfiguration passt nicht exakt ins Grid!');
        }

        const bigBlocks = []; // Positionen der 2x2-Blöcke (top-left)

        function blocksOverlap(r1, c1, r2, c2) {
            // Prüfen, ob sich zwei 2x2-Blöcke überlappen
            return !(r1 + 1 < r2 || r1 > r2 + 1 || c1 + 1 < c2 || c1 > c2 + 1);
        }

        // Zufällig zwei 2x2-Blöcke setzen (ohne Überlappung)
        while (bigBlocks.length < BIG_SECTORS) {
            const r = Math.floor(Math.random() * (ROWS - 1)); // 0..ROWS-2
            const c = Math.floor(Math.random() * (COLS - 1)); // 0..COLS-2

            let ok = true;
            for (const b of bigBlocks) {
                if (blocksOverlap(r, c, b.row, b.col)) {
                    ok = false;
                    break;
                }
            }
            if (!ok) continue;

            bigBlocks.push({ row: r, col: c });
        }

        function cellInBig(r, c) {
            // Gibt den Block zurück, falls diese Zelle in einem 2x2-Block liegt
            return bigBlocks.find(b =>
                r >= b.row && r <= b.row + 1 &&
                c >= b.col && c <= b.col + 1
            );
        }

        // Sectors mit fester Position vorbereiten
        const sectorsConfig = [];
        let id = 1;

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const block = cellInBig(r, c);

                if (block) {
                    // Zelle gehört zu einem großen Block
                    if (r === block.row && c === block.col) {
                        // nur oben links erzeugen wir das große Element
                        sectorsConfig.push({
                            id,
                            rowStart: r + 1,   // Grid ist 1-basiert
                            colStart: c + 1,
                            big: true
                        });
                        id++;
                    }
                    // andere 3 Zellen des Blocks werden vom großen Element überdeckt
                } else {
                    // normaler Sector
                    sectorsConfig.push({
                        id,
                        rowStart: r + 1,
                        colStart: c + 1,
                        big: false
                    });
                    id++;
                }
            }
        }

        // Sicherheitscheck: wir sollten genau 26 Sectors haben
        if (sectorsConfig.length !== TOTAL_SECTORS) {
            console.warn('Anzahl der erzeugten Sectors stimmt nicht:', sectorsConfig.length);
        }

        // DOM erzeugen
        const mainbody = document.getElementById('mainbody');

        sectorsConfig.forEach(cfg => {
            const div = document.createElement('div');
            div.classList.add('sectors');
            if (cfg.big) div.classList.add('big');

            // Nummer anzeigen (z.B. 01, 02, 03, ...)
            div.textContent = String(cfg.id).padStart(2, '0');

            // Position im Grid explizit setzen
            div.style.gridRowStart = cfg.rowStart;
            div.style.gridColumnStart = cfg.colStart;

            mainbody.appendChild(div);
        });
    </script>
</body>
</html>
